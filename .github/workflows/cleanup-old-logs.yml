name: Cleanup Old MongoDB Logs (7 Days)

on:
  schedule:
    # Run daily at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run - only show what would be deleted'
        required: false
        default: 'false'
        type: boolean

permissions:
  actions: write
  contents: read

jobs:
  cleanup-logs:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Create log cleanup script
        run: |
          cat > cleanup-old-logs.js << 'EOF'
          /**
           * Robust MongoDB log cleanup script for GitHub Actions
           *
           * Behavior:
           *  - Uses MONGODB_URI from environment (secrets)
           *  - Uses DATABASE_NAME env var if provided (overrides URI)
           *  - If db name is not provided, attempts a safe extraction from URI
           *  - Validates extracted DB name length to avoid Atlas "name too long" error
           *  - Supports dry run via --dry-run or DRY_RUN=true
           */

          const mongoose = require('mongoose');

          const MONGODB_URI = process.env.MONGODB_URI;
          const DATABASE_NAME = process.env.DATABASE_NAME || null;
          const DRY_RUN = process.argv.includes('--dry-run') || process.env.DRY_RUN === 'true';

          function ensureScheme(uri) {
            if (!uri) throw new Error('MONGODB_URI is required in environment variables');
            if (uri.startsWith('mongodb://') || uri.startsWith('mongodb+srv://')) return uri;
            // If user supplied a host:port style string, prefix with mongodb+srv
            return 'mongodb+srv://' + uri;
          }

          // Safely extract database name from connection string
          function extractDbFromUri(uri) {
            try {
              // Remove credentials portion first to avoid accidental matches
              // Match the first slash after the host and capture the segment up to ? or /
              // Example matches:
              // mongodb+srv://user:pass@host/dbname?retryWrites=true -> captures dbname
              const match = uri.match(/^[^\/]+\/\/[^\/]+\/([^?\/]+)(?:[?\/]|$)/);
              if (match && match[1]) {
                return decodeURIComponent(match[1]);
              }
            } catch (e) {
              // fall through
            }
            return null;
          }

          (async function main() {
            try {
              const rawUri = ensureScheme(MONGODB_URI);
              let dbName = DATABASE_NAME || extractDbFromUri(rawUri);

              if (dbName && dbName.includes('?')) {
                // strip any accidental query part
                dbName = dbName.split('?')[0];
              }

              if (dbName) {
                const byteLen = Buffer.byteLength(dbName, 'utf8');
                // Atlas error message you saw complained about max 38 bytes
                if (byteLen > 38) {
                  throw new Error(`Extracted database name "${dbName}" is ${byteLen} bytes which is longer than allowed by your server (Atlas may enforce 38 bytes). Provide a shorter DATABASE_NAME secret or fix the URI.`);
                }
              }

              const connectOptions = {};
              if (dbName) connectOptions.dbName = dbName;

              console.log('üîå Connecting to MongoDB', {
                dbName: dbName || '<no-db-in-uri-or-secret>',
                dryRun: DRY_RUN,
              });

              await mongoose.connect(rawUri, connectOptions);
              console.log('‚úÖ Connected to MongoDB');

              // Define log schema
              const logSchema = new mongoose.Schema({
                level: {
                  type: String,
                  enum: ['error', 'warn', 'info', 'debug'],
                  required: true,
                },
                message: {
                  type: String,
                  required: true,
                },
                meta: {
                  type: mongoose.Schema.Types.Mixed,
                  default: {},
                },
                route: {
                  type: String,
                  required: true,
                },
                timestamp: {
                  type: Date,
                  default: Date.now,
                  index: true,
                },
                userId: {
                  type: String,
                  default: null,
                },
                sessionId: {
                  type: String,
                  default: null,
                },
              }, { timestamps: false });

              logSchema.index({ timestamp: -1 });
              logSchema.index({ level: 1, timestamp: -1 });

              const Log = mongoose.models.Log || mongoose.model('Log', logSchema);

              // Calculate cutoff
              const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
              console.log(`üîç Finding logs older than ${sevenDaysAgo.toISOString()}`);

              const oldLogsCount = await Log.countDocuments({
                timestamp: { $lt: sevenDaysAgo },
              });

              console.log(`üìä Found ${oldLogsCount} logs older than 7 days`);

              if (oldLogsCount === 0) {
                console.log('‚úÖ No logs to delete');
                await mongoose.disconnect();
                return process.exit(0);
              }

              // Show a few samples
              const sampleLogs = await Log.find({
                timestamp: { $lt: sevenDaysAgo }
              })
                .sort({ timestamp: 1 })
                .limit(5)
                .select('_id level message route timestamp')
                .lean();

              console.log('\nüìã Sample logs to be deleted:');
              sampleLogs.forEach((log, idx) => {
                const msgPreview = (log.message || '').substring(0, 120) + ((log.message || '').length > 120 ? '...' : '');
                console.log(`${idx + 1}. [${(log.level || 'info').toUpperCase()}] ${log.route}: "${msgPreview}"`);
                console.log(`   Time: ${new Date(log.timestamp).toISOString()}`);
                console.log(`   _id: ${log._id}`);
              });

              if (DRY_RUN) {
                console.log(`\nüîç DRY RUN: Would delete ${oldLogsCount} logs. No deletion performed.`);
                await mongoose.disconnect();
                return process.exit(0);
              }

              console.log('üóëÔ∏è  Deleting old logs...');
              const result = await Log.deleteMany({
                timestamp: { $lt: sevenDaysAgo }
              });

              console.log(`‚úÖ Successfully deleted ${result.deletedCount} logs`);
              await mongoose.disconnect();
              return process.exit(0);
            } catch (err) {
              console.error('‚ùå Error:', err && err.message ? err.message : err);
              try { await mongoose.disconnect(); } catch (_) {}
              return process.exit(1);
            }
          })();
          EOF

      - name: Run log cleanup
        env:
          MONGODB_URI: "${{ secrets.MONGODB_URI }}"
          DATABASE_NAME: "${{ secrets.DATABASE_NAME }}"
          DRY_RUN: "${{ github.event.inputs.dry_run || 'false' }}"
        run: |
          echo "Running cleanup with DRY_RUN=$DRY_RUN"
          node cleanup-old-logs.js

      - name: Cleanup
        if: always()
        run: |
          # Remove the cleanup script
          rm -f cleanup-old-logs.js
